# Вариации страниц
## Задача

На стадии вёрстки может возникнуть необходимость показать заказчику или менеджеру несколько вариантов одной и той же
  страницы.
Как правило, это варианты, зависящие от состояний.

Например, если на странице отображается коллекция каких-либо сущностей (скажем, товаров в интернет-магазине), то у 
  одной и той же страницы будут как минимум следующие состояния:

  * Данные в процессе получения. Обычно в этом состоянии отображаются анимированные серые фигуры, называемые
    "content placeholder", "skeleton loading" и так далее.
  * Ошибка получения данных. Обычно в этом состоянии отображается сообщение об ошибке.
  * Сообщение о том, что нет сущностей. В этом состоянии следует отобразить соответствующее сообщение.
  * Сообщение о том, что сущности есть, но нет результатов поиска. В этом состоянии следует отобразить соответствующее
    сообщение и можно предложить сбросить условия фильтрации.
  * Данные получены и отображаются
 
К этой же задаче можно отнести создание вариантов страниц для разных языков, однако локализация имеет отношение 
  не только к стадии статического превью, но и к другим этапом тоже.
Поэтому задача локализации рассмотрена в [отдельной статье](#), однако здесь мы рассмотрим случай, когда нужны 
  комбинации по состояниям и языкам.


### Что было до YDA

Если говорить о написании сырого HTML кода, то предстояло одновременно поддерживать несколько похожих HTML-файлов.
Если у файлов есть общий для нескольких страниц HTML-код (например, общие шапка, подвал, сайдбар и так далее), то для
того, чтобы внести изменения в эти элементы, приходилось редактировать все файлы.
Даже если у конкретной 5 состояний и 2 языка, то на одну эту страницу приходилось бы 10 HTML-файлов на стадии вёрстки.

Pug и другие препроцессоры, конечно, дают возможность значительно уменьшить рутины насчёт использования условного рендеринга.
Однако, в случае данной задачи рутин по-прежнему остаётся много.
Например, мы можем создать шаблон страницы, от которого будем наследовать конкретные её реализации:

```pug
extend Layouts/MainLayout.pug

  block append Settings
  
    -
    
      class ProductListPage {
      
        static locale = null;
        
        static States = {
          loadingInProgress = "",
          error = "",
          noData = "",
          noSearchResults = "",
          normalDisplaying = ""
        }
        
        static state = ProductListPage.normalDisplaying;
        
        static setLocale(locale) {
          ProductListPage.locale = locale;
          return ProductListPage;
        }
        
        static setState(state) {
          ProductListPage.state = state;
          return ProductListPage;
        }
      
      }

    block PageDependentContent
      
      h1 Products List
      
      case ProductListPage.state
      
        when ProductListPage.States.loadingInProgress
        when ProductListPage.States.error
        when ProductListPage.States.noData
        when ProductListPage.States.noSearchResults
        default
```

Теперь чтобы например создать испанскую версии вариации "нет результатов поиска", надо создать файл с именем, скажем,
**ProductsListPage-NoSearchResults.spanish.pug** и вызывать методы класса `ProductsListPage` с нужными параметрами:

```pug
block append Settings

  - 
    ProductListPage.
        setLocale(Locales.Spanish).
        setState(ProductListPage.States.noSearchResults);
```

И таких файлов в нашем примере нужно подготовить 10 штук, а общем случае - количество состояний умноженное на количество
локализаций.
YDA берёт на себя эту рутину.


## Решение YDA

Все зависимости от того, сколько состояний и сколько языков у Вас будет, среди исходных файлов, для каждой страницы у
Вас будет только одна точка входа:

```
extend Layouts/MainLayout.pug

  block append Settings
  
    - const pageStringResources = $stringResources.pages.productsList; 
    
    block PageDependentContent
      
      h1 Products List
      
        if productListPageStatesSimulations.isLoadingInProgress
        
        else if productListPageStatesSimulations.isError
        
        else if productListPageStatesSimulations.isNoData
        
        else if productListPageStatesSimulations.isNoSearchResults
        
        else
        
          // ...
```

Откуда взялись переменные $stringResources и productListPageStatesSimulations?
Из настроек, которые теперь описываются в декларативном виде:

```yaml

```

Как видно, настройки зависящих от вариации страниц вынесены в отдельный файл.
Сделано так потому, что по мере роста количество страниц объём этого файла будет тоже расти, и если объявлять эти
настройки в общем файле конфигурации, то они могут занять большую его часть, в то время как имеют отношение
исключительно к режиму статического превью, при этом к одной конкретной функциональности.

```yaml

```

[//]: # (TODO Придётся создать тестовый проект)

## Пошаговая инструкция
### Создание вариаций, зависящих от состояния

1. В **yda.config.yaml**

```
$projectBuilding:

  // ...

  $markupProcessing:

    $staticPreview:

      $pagesVariations:

        $stateDependent:
          
          $specificationFileRelativePath: People.StaticPreview/PagesStateDependentVariations.yaml
```


### Создание вариаций, зависящих от локализаций
#### Хранение строковых ресурсов в TypeScript

#### Хранение строковых ресурсов в JSON


### Созданий вариаций, зависящих от состояний и локализаций

Приведённые выше настройки никоим образом не конфликтуют - Вы можете просто их собрать воедино:

```Pug

```

Единственное, что теперь изменится - это ссылки на файлы.
Для этого нужно знать соглашение, согласно которого файлам присваиваются имена:

```
[Основное имя][постфикс состояни].[промежуточное расширение локали].html
```

Таким образом:


```Pug

```
