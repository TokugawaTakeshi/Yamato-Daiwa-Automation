# ブラウザーキャッシング副作用対策

## (ブラウザー)キャッシングとは
**御存知で無い方へ**

Файлы скриптов, стилей, изображений и так далее скачиваются уже после того, как браузер получил HTML-код и начал
рендерить отображение (за исключение случаев, когда стили и скрипты находятся внутри самого HTML-файла, но это не обязательно
хорошо). 
Отрисовывание страницы первый раз может занять значительное время, особенно если на странице много
изображений и много логики ([пример](#)). Кроме того, это нагрузка на сервер, особенно если речь идёт о больших файлах
таких как изображения высокого разрешения, видео и так далее.

Чтобы уменьшить время загрузки страницы при её повторном отрисовывании, браузер сохраняет скаченные файлы на жесткий
диск и при повторном заходе на страницу не обращается к серверу, а берёт их именно оттуда. С одной стороны, это положительно
сказывается на скорости загрузки страницы. С другой стороны, снижается нагрузка на сервер.

Но eстественно, что чем больше пользователь смотрит разные сайты (а делается не только ради развлечения, но и для сбора
информации в рамках работы), тем больше происходит захламление памяти. Люди, собирающие информацию, часто заходят на один
и тот же сайт только один раз, а кэширование происходит без разбора. 

Поэтому и операционные системы, и браузеры, и сторонний софт такой как CCLeaner предоставляют возможность очитки кэша -
как в автоматическом режиме, так и вручную. Это значит, что разработчики должны учитывать оба сценария - когда кэширование
есть и когда его нет.

Первый случай важен тогда, когда мы обновляем сайт, например стили или скрипты, или же заменили одно изображение на другое
без изменения имени файла. 
Если пользователь единыжды посмотрел на сайт, и у него закэшируется, например, `Styles.css`, то после загрузки нового
`Styles.css` на сервер пользователь этого файла просто-напросто не получит, а отображение будет в соответствии со старым
`Styles.css`.  Особенно это критично в случаях, когда мы добавляем новые компоненты (тогда у них просто не будет стилей), 
и когда исправляем изъяны.

Решением данной проблемы является добавление уникального постфикса к имени файла, например `Styles--d41d8cd98f.css`.
Обычно для создания уникальной строки используется UNIXStamp или генерация случайного числа, однако в этом случае при
каждой пересборке проекта все файлы, в том числе и те, которые не были изменены, будут получать новый постфикс.
Это наоборот сведёт на нет те преимущества, которые даёт кэширование, поэтому постфикс следует генерировать таким образом,
чтобы он не менялся, если файл не был изменён. Для этого вполне подходит алгоритм MD5, применяемый по отношению к содержимому
файла. 

Вне зависимости от содержимого файла он получается коротким, а потому префиксованный файл `имеет вид как `Styles--d41d8cd98f.css`.


### Соответствие

Если имя файла было изменено в автоматическом режиме (например с `Styles.css` на `Styles--d41d8cd98f.css`), то об этом
узнает серверное приложение? Скорее всего, сервер использует какую-нибудь систему шаблонизации, и так Handlebars-подобном
синтаксисе есть что-вроде `<link href="{{ assets("Styles.css") }}" rel="stylesheet">`. Функция-хелпер `assets` должна
знать откуда брать не просто файл `Styles.css`, а его префиксованную версию `Styles--d41d8cd98f.css`.

Для этого, в процессе сборки фронт-енд части обычно генерируется файл, в котором содержится соответствие непрификсованных
имен файлов и префиксованных. Его называют "Манифест", но с этим названием есть проблемы.


### Неоднозначность слова "Манифест"

Слово "манифест" насколько 乱用されているので, что на вопрос "а что содержится в манифесте?" более точно ответа чем 
"какие-то метаданные" не существует. Манифест имеют AMP приложения, манифест требуют PWA приложения; ну и как было
указанно выше, манифест используется для поиска префиксованных файлов, для чего существуют специальные gulp-плагины.
И все предлагают имя по умолчанию `manifest.json`.


## 「ひかり：自動化」に於ける

Поскольку добавление хэша является базовым спросом рынка, то по умолчанию эта опция включена для режима тестовой сборки
и продакшен все типов файлов, кроме разметки. На данный момент, глобального выключателя для все типов файлов и всех
точек не предусмотрено. Отключить можно, укав параметр `飛: true` в настройках группы точек входа или группы ассетов:

```yaml
構成モード関連:
  ファイル名於内容指標:
    飛: false 
```

По умолчанию, хэш отделяется двойным дефисом, например `Styles--d41d8cd98f.css`.
Изменить это можно указав свой:

```yaml
構成モード関連:
  ファイル名於内容指標:
    内容暗号後置カスタム区切: __ 
```


### Генерация манифеста

「ひかり：自動化」 не нуждается в манифесте для того, чтобы собрать приложение и правильно просчитать пути.
Но манифест могут требовать серверные приложения. Есть несколько способов генерации манифестов:

1. Генерация одного манифеста для всех типов файлов и всех групп точек входа и ассетов.
2. Генерация манифеста для каждого типа файлов
3. Генерация манифеста для каждой группы точек входа или группы ассетов
